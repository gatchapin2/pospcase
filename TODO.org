
#+SEQ_TODO: TODO(t!) NOTE(n!) | DONE(d!) HALT(h!)
* Scheduled
** TODO Submatcher reorganization
   - State "TODO"       from              [2018-12-10 Mon 03:38]

   API design should follow consistent criteria.
** TODO Comments
   - State "TODO"       from              [2018-12-10 Mon 03:38]
* Bugs
** TODO Known reader macros so far
   - State "TODO"       from              [2018-11-21 Wed 01:42]
   - #\char
   - #H() from cl21
   - #!?[-+]sym
   - #(1 2 3)
   - #2A((1) (2))
   - #123#
   - #| |#
   - #.(foo)

** TODO replace-regex-in-string ideas [5/5]
   - State "TODO"       from              [2018-11-21 Wed 01:42]
   - [X] "#\\" -> " ?", a half assed char conversion
   - [X] "#[^ (]+(" -> "(", for cl21 hash
   - [X] "#p\"" -> "\"", pathname
   - [X] "#\\+" -> "  "
   - [X] "#|foo|#" -> "/*   */"

** TODO ~pospcase–buffer-substring~ can’t read "#\\\\"
   - State "TODO"       from              [2018-12-05 Wed 03:50]

** TODO unreliable forward-sexp
   - State "TODO"       from              [2018-12-21 Fri 14:07]
   Known problematic cases:
   - #2A((1) (2))
   - #.(foo)

   Do they break nth-chop-off?

** TODO Reorder keywords for parameter-group
   - State "TODO"       from              [2018-12-23 Sun 14:45]

   - To properly highlight the following declaration:

     #+BEGIN_SRC emacs-lisp
       (defun foo (&key (quote #'bar) (function ’baz)))
     #+END_SRC

     The keywords order should be:

     1. ~#'baz~ and ~&key~, by non-pospcase keywords
     2. parameter-group, (including masked and ignored heading-keyword ~&key~)
     3. ~quote~ and ~function~, lisp keywords that can be both macro and symbol

* Features
** TODO Use as much ~pcase~ as possible
   - State "TODO"       from              [2018-11-19 Mon 12:27]
** TODO elispification
   - State "TODO"       from              [2018-11-19 Mon 13:34]
** submatcher generator
   - Something like:

     #+BEGIN_SRC emacs-lisp
       (pospcase-font-lock ’lisp-mode
                            '(`(defun ,name ,args))
                            '((name . font-lock-function-name-face)
                              ((args . (`(,arg ,type)
                                        `,arg)))
                              ((arg . font-lock-function-name-face)
                               (type . font-lock-type-face))))
     #+END_SRC

     and it calls

     #+BEGIN_SRC emacs-lisp
       (goto-char (car args))
       (pospcase-font-lock-submatcher (`(,arg ,type)
                                       `,arg))
     #+END_SRC
** TODO define ~pospcase--after-open-paren~
   - State "TODO"       from              [2018-11-23 Fri 11:11]

     #+BEGIN_SRC emacs-lisp
       (let ((limit (point-max))
             (keyword "defun"))
         (when (search-forward keyword limit t)
           (let ((kw-begin (match-beginning 0))
                 (kw-end (match-end 0))
                 begin end)
             (and
              (looking-at "[ \t\n;]")
              (setq end (match-end 0))
              (search-backward "(" nil t)
              (setq begin (match-beginning 0))
              (progn
                (goto-char (match-end 0))
                (forward-comment most-positive-fixnum)
                (= (point) kw-begin))
              (set-match-data (list begin end
                                    kw-begin kw-end)))))
         (match-string 1))

       ;;; bar
       (
       ;;; foo
       defun foo (bar) baz)
     #+END_SRC
** TODO Primary matcher should use pcase too?
   - State "TODO"       from              [2018-11-23 Fri 14:13]

   - Example: `((or labels cl-labels) ,name ,args . ,__)
** TODO Should I make ~pospcase-let~?
   - State "TODO"       from              [2018-12-04 Tue 11:07]
** TODO Consider trailing match for submatchers
   - State "TODO"       from              [2018-12-20 Thu 12:00]
   Currently use cases I can think are ~defstruct~ and ~setq~:

   #+BEGIN_SRC emacs-lisp
     `(defstruct ,name . ,slots)
   #+END_SRC

   and:

   #+BEGIN_SRC emacs-lisp
     `(setq . ,binds)
   #+END_SRC

   Advantages:
     - It looks more proper.
     - May elegantly cover some future pattern I’m not currently aware of.

   Disadvantage:
     - Unnecessary computation. (no chopping off)
     - Doesn’t cooperate well with fence-start (maybe requires rework?)
** TODO What to do with case insensitivity?
   - State "TODO"       from              [2018-12-20 Thu 14:12]
** TODO ignore-errors should be togglable
   - State "TODO"       from              [2018-12-23 Sun 14:50]
* Documentation
** NOTE should I mention the difference between ~pospcase-read~ and ~read-symbol-positions-list~ ?
   - State "NOTE"       from              [2018-12-02 Sun 04:10]

   #+BEGIN_SRC emacs-lisp
     (let ((read-with-symbol-positions t))
       (read "(foo (foo))")
       read-symbol-positions-list)
   #+END_SRC

* Design guideline
** NOTE errors
   - State "NOTE"      from              [2018-11-22 Thu 10:32]

   - Generic functions like ~pospcase~, ~pospcase-at~, ~pospcase-read~
     shouldn't silently discard errors like ~scan-error~ for unmatched
     parenthesis, ~invalid-read-syntax~ for unparsable buffer segment
     even after elispification.

   - Externally exposed font-lock functions (submatchers, preform,
     postform, etc.) and macros should discard errors silently.

   - How about internal font-lock functions (iterator, etc)?
** TODO use idioms
   - State "TODO"       from              [2018-11-29 Thu 11:24]
   - use push

     #+BEGIN_SRC emacs-lisp
       (cl-loop with result do (setq result (append result (walk))))
     #+END_SRC

     should be

     #+BEGIN_SRC emacs-lisp
       (cl-loop with result do (push (walk) result))
     #+END_SRC
** TODO ~read-from-string~ should be major-mode aware? In case someone use (pred vectorp) in emacs-lisp-mode?
   - State "TODO"       from              [2018-11-30 Fri 09:37]
** TODO ~down-list~ is major-mode aware. Does ~elispify~ cause inconsistency?
   - State "TODO"       from              [2018-11-30 Fri 09:43]
** TODO consistent arity-like submatcher naming convention
   - State "TODO"       from              [2018-12-04 Tue 17:16]
