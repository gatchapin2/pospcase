(defun sexp-font-lock-read-at-point ()
  "Parse the s-expression at the cursor position. Return a
s-expression with the tokens being replaced with the cons. With
which `car' is original token, and `cdr' is positional metadata
of the token as a cons in (begin . end)."
  (cl-labels
      ((walker (limit)
               (destructuring-bind (start sexp . lim)
                   (cons (point)
                         (read-from-string
                          (buffer-substring-no-properties (point) limit)))
                 (incf lim (point))
                 (forward-comment lim)
                 (cons
                  (if (or (atom sexp)
                          (memq (car sexp) '(\` quote)))
                      sexp
                    (down-list)
                    (cl-loop
                     with str
                     with rpair
                     with dot
                     with temp
                     with result
                     do (setq str (progn
                                    (forward-comment lim)
                                    (buffer-substring-no-properties (point) lim))
                              rpair
                              (condition-case err
                                  (read-from-string str)
                                (invalid-read-syntax
                                 (when (string= (cadr err) ".")
                                   (setq dot t
                                         str (progn
                                               (forward-sexp)
                                               (forward-comment lim)
                                               (buffer-substring-no-properties (point) lim)))
                                   (read-from-string str))))
                              rlim (+ (point) (cdr rpair))
                              temp (if (or (atom (car rpair))
                                           (memq (car rpair) '(\` quote)))
                                       (cons (car rpair) (cons (point) rlim))
                                     (save-excursion
                                       (walker rlim))))
                     if dot
                     do (setq result (cons result temp))
                     else
                     do (setq result (append result (list temp)))
                     until (progn
                             (condition-case nil
                                 (forward-sexp)
                               (error nil))
                             (forward-comment lim)
                             (while (> (skip-chars-forward ")") 0)
                               (forward-comment lim))
                             (>= (point) lim))
                     finally return result))
                  (cons start lim)))))
    (save-excursion (walker (scan-sexps (point) 1)))))

(defmacro sexp-font-lock-translate-pattern (exp)
  "Translate `pcase' pattern to fit s-expression generated by
`sexp-font-lock-read-at-point'. Nested backquote is not
supported (maybe `pcase' doesn't support it too?)."
  (cl-labels
      ((meta-pos-symbol (sym)
                        (list '\,
                              (intern (concat
                                       (symbol-name (cadr node))
                                       "-meta-pos"))))
       (walker (node)
               (if (consp node) ; note that in elisp `,foo' is `(\, foo)'
                   (cond
                    ((eq (car node) 'quote)
                     (cons node ',_))
                    ((eq (car node) '\,)
                     ;; ,\\= is NOT supported since it
                     ;; requires fetching and unwrapping
                     ;; next (quote foo) into foo.
                     (if (or (eq (cadr node) '_)
                             (and
                              (consp (cadr node))
                              (memq (caadr node) '(or and pred guard let app))))
                         (cons node ',_)
                       (cons node (meta-pos-symbol (cadr node)))))
                    (t (cons
                        (cl-loop
                         with result
                         do (cond
                             ((and (atom (cdr node))
                                   (cdr node))
                              (cl-return
                               (cons
                                (append result (list (walker (car node))))
                                (walker (cdr node)))))
                             ((memq (car node) '(\` \, quote))
                              (setq result (append
                                            result
                                            (if ; cdr cell ,foo matches the rest of a list
                                                (and (null (cddr node))
                                                     (symbolp (cadr node)))
                                                (meta-pos-symbol (cadr node))
                                              (walker (list (car node) (cadr node)))))
                                    node (cddr node)))
                             ((or (car node)
                                  (cdr node))
                              (setq result (append result (list (walker (car node))))
                                    node (cdr node)))
                             (t (cl-return result))))
                        ',_)))
                 (cons node ',_))))
    (if (consp exp)
        (case (car exp)
          ('quote (list 'quote (list '\` (cons exp ',_))))
          ('\` (list 'quote (list '\` (walker (cadr exp)))))
          (otherwise (list 'quote (walker exp)))))))

(defmacro sexp-font-lock-match-at-point (&rest cases)
  `(pcase
       ,(list 'quote (sexp-font-lock-read-at-point))
     ,@(mapcar
        (lambda (case)
          (list
           (eval (macroexpand `(sexp-font-lock-translate-pattern ,(car case))))
           (cond
            ((and (listp (cadr case))
                  (eq (caadr case) 'list))
             (cons
              'list
              (mapcar (lambda (sym)
                        (intern (concat
                                 (symbol-name sym) "-meta-pos")))
                      (cdadr case))))
            ((symbolp (cadr case))
             (intern (concat
                      (symbol-name (cadr case)) "-meta-pos")))
            (t (error "This macro is designed for extracting \
positional metadata, and not to be used as generic control \
structure. Complex operations are not supported.")))))
        cases)))

(defun sexp-font-lock-match-at-point-do (pat)
  (eval (macroexpand `(sexp-font-lock-match-at-point ,pat))))

(defun sexp-mark-pattern-at-point (pat)
  (interactive "xPattern to match: ")
  (let ((match (sexp-font-lock-match-at-point-do pat)))
    (when match
      (cond
       ((numberp (cdr match))                                ; (BEG . END)
        (goto-char (car match))
        (push-mark (cdr match) nil t))
       ((and (consp (cdr (car match)))
             (numberp (cddr (car match))))                   ; ((SEXP BEG . END)
                                                             ;  ... (SEXP BEG . END))
        (goto-char (cadr (car match)))
        (push-mark (cddr (car (last match))) nil t))
       (t
        (goto-char (if (numberp (car (car match)))           ; ((BEG . END) ...)
                       (car (car match))
                     (cadar (car match))))                   ; (((SEXP BEG . END) ...) ...)
        (push-mark (if (numberp (cdr (car (last match))))    ; (... (BEG . END))
                       (cdr (car (last match)))
                     (cddr (car (last (car (last match)))))) ; (... (... (SEXP BEG . END)))
                   nil t))))))


;; (sexp-mark-pattern-at-point '(`(defun ,name . ,rest) name))

;;; Work-in-progress codes

(defvar sexp-font-lock--matches nil)
(defun sexp-font-lock--iterator ()
  (if sexp-font-lock--matches
      (let ((mlist (cl-loop for pair in (car sexp-font-lock--matches)
                            append (-cons-to-list pair))))
        (set-match-data (append (cons (car mlist)
                                      (last mlist))
                                mlist))
        (setq sexp-font-lock--matches (cdr sexp-font-lock--matches))
        t)
    (set-match-data nil)))
(defmacro sexp-font-lock-iterate (clause limit) ; is macro to catch parsing error
  `(condition-case nil
       (when (or (< (point) limit) sexp-font-lock--matches)
         (unless sexp-font-lock--matches ; initialize
           (setq sexp-font-lock--matches ,clause)
           (goto-char ,limit)) ; whole parsing is already done, it's not crawler
         (sexp-font-lock--iterator))
     (error
      (goto-char ,limit))))

(defun  sexp-font-lock-match-flat-list (limit)
  (sexp-font-lock-iterate
   (progn
     ;; (backward-char)                    ; lisp-extra-font-lock-keywards compatibility
     (mapcar (lambda (srpair) (list (cdr srpair)))
             (car (sexp-font-lock-read-at-point))))
   limit))

;; (fset #'lisp-extra-font-lock-match-argument-list-orig (symbol-function #'lisp-extra-font-lock-match-argument-list))
;; (fset #'lisp-extra-font-lock-match-argument-list (symbol-function #'sexp-font-lock-match-flat-list))
;; (font-lock-fontify-buffer)
;; (fset #'lisp-extra-font-lock-match-argument-list (symbol-function #'lisp-extra-font-lock-match-argument-list-orig))

;; (and (sexp-font-lock-match-flat-list (scan-sexps (point) 1))
;;      (match-string 1))

;; (foo bar baz)

;; (setq sexp-font-lock--matches nil)

;; (cl-loop with p = (scan-sexps (point) 1)
;;          while (sexp-font-lock-match-flat-list p)
;;          collect (match-string 1))

;; (foo bar)

(defun sexp-font-lock-match-varlist (limit)
  (sexp-font-lock-iterate
   (progn
     ;; (backward-char)     ; lisp-extra-font-lock-keywards compatibility
     (mapcar
      (lambda (srpair)
        (or (progn
              (goto-char (cadr srpair))
              (sexp-font-lock-match-at-point-do '(`(,name ,type) (list name type))))
            (list (cdr srpair))))
      (car (sexp-font-lock-read-at-point))))
   limit))

;; (defvar sexp-debug-counter 0)
;; (setq sexp-debug-counter 0)
;; (setq sexp-font-lock--matches nil)

;; (and (sexp-font-lock-match-varlist (scan-sexps (point) 1))
;;      (match-string 1))

;; (cl-loop with p = (scan-sexps (point) 1)
;;          while (sexp-font-lock-match-varlist p)
;;          collect (list (cons 'name (match-string-no-properties 1))
;;                        (cons 'type (or (match-string-no-properties 2) 'unknown))))

;; ((foo bar) baz (quux meow))


(defun sexp-font-lock-match-flet (limit)
  (sexp-font-lock-iterate
   (progn
     ;; (backward-char)     ; lisp-extra-font-lock-keywards compatibility
     (mapcar
      (lambda (srpair)
        (goto-char (cadr srpair))
        (multiple-value-bind
            (name args)
            (sexp-font-lock-match-at-point-do '(`(,name ,args . ,rest) (list name args)))
          (list name
                (progn
                  (goto-char (1- (cadr args)))
                  (mapcar (lambda (srpair) (list (cdr srpair)))
                          (car (sexp-font-lock-read-at-point)))))))
      (car (sexp-font-lock-read-at-point))))((foo (bar) baz))
   limit))

