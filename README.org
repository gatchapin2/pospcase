#+TITLE: ~pospcase~: A ~pcase~ variant for getting positional metadata

* About ~pospcase~
  ~pospcase~ is a package for extracting S-expression positions using
  ~pcase~ pattern matching ability.

  At this moment the package contains a pattern matcher ~pospcase~ and a
  pretty advanced code highlighter for ~lisp-mode~ and ~emacs-lisp-mode~.

* Rational
  Emacs’s font-locking (highlighting) heavily relies on regular
  expression (regexp). There’s already an attempt to do [[https://github.com/Lindydancer/lisp-extra-font-lock][extra
  highlighting]] for Lisp and Emacs Lisp. Which is completely regexp
  based. When you follow the above link and look into its
  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html][anchored-matcher]], let’s say ~lisp-extra-font-lock-match-let~ for
  example.  you’ll notice parsing S-expression with regexp is
  inherently awkward and error-prone (you also notice in-between
  comments break the parsing too). To overcome the problem, you
  basically have to call ~syntax-ppss~ and ~forward-comment~ everywhere in
  pattern matching part of your code. The resulting code is quite
  unreadable mess of regexp matchings, constant syntax-table
  checkings, and numerous corner-case coverages. If you want to see
  what kind of mess it will be. Here’s an example:

  #+BEGIN_SRC emacs-lisp
    ;;; match and collect all symbol positions within the same nested level
    (let ((current-level (car (syntax-ppss)))
          (symbol-pat "\\_<\\(?:\\sw\\|\\s_\\)+\\_>")
          (skip-pat "\\(?:\\sw\\|\\s_\\|\\s \\)"))

      (if (zerop current-level)
          (error "The point is in the top level.")
        (backward-up-list)
        ;; skip the starting non-symbol chars
        (skip-chars-forward skip-pat)

        (cl-loop
         with result

         ;; return if the task ended or the `point' is out of scope
         when (or (eobp) (< (car (syntax-ppss)) current-level)) return result

         ;; actual matching
         do (progn
              (forward-comment most-positive-fixnum)
              (looking-at symbol-pat))

         ;; collect matched symbol's range in a cons pair
         if (= (car (syntax-ppss)) current-level)
         do (setq result (cons (cons (match-beginning 0) (match-end 0)) result))

         ;; skip non-interesting characters
         do (progn
              (goto-char (match-end 0))
              (skip-chars-forward skip-pat)))))
  #+END_SRC

  Next I present you what kind of code it will be like if you use
  ~pospcase-read~, the S-expression reader I implemented, to get the
  same result:

  #+BEGIN_SRC emacs-lisp
    ;;; collect all symbol positions within the same nested level
    (if (zerop (car (syntax-ppss)))
        (error "The point is in the top level.")
      (backward-up-list)

      (cl-loop for pair in (car (pospcase-read (point))) ; `car' because `cdr' contains
                                                         ; position data of entire list
               if (symbolp (car pair)) collect (cdr pair)))

  #+END_SRC

  Well, I admit it’s exaggerated to illustrate the point. The actual
  code is messier than this. But I hope you see some novelty behind
  it.

  In addition, Emacs recently got this nice pattern matching macro
  called ~pcase~. Nowadays You can easily match and destructure any kind
  of S-expression whenever you want.

  So I decided it’s a good time to write a ~pcase~-based position
  extractor and use it for a lisp code highlighter.

* How to Enable Pospcase Font Lock
  To turn on the font-lock for lisp-mode and emacs-lisp-mode, eval the
  following code:

  #+BEGIN_SRC emacs-lisp
    (require 'pospcase)
    (pospcase-font-lock-lisp-setup)
  #+END_SRC

  The above code add ~pospcase-font-lock-lisp-keywords~add~ to the said
  two lisp major-modes’ hooks. Currently ~pospcase-font-lock~ doesn’t
  have minor-mode unlike ~lisp-extra-font-lock~. The reason is I
  designed the font-lock specific functions so I can easily making
  buffer-local keywords. Then I can simultaneously work on different
  codebases in a single Emacs session with different highlighting
  rules with the same keywords for each codebases. It may never
  happened to you, but I’ve actually seen two codebases define ~defun*~
  by themselves with completely different meanings with different
  argument styles (one of them enforce type check with ~->~
  (dash-greater-than) arrow syntax).

  If you want to enforce the same highlighting rule to a single
  major-mode, minor-mode is the best way to do it. But your workflow
  involves numerous per-project highlighting rules, I feel there’s not
  much point using minor-mode for it.

  But, by all means I don’t oppose defining your own minor-mode. You
  can write it by simply using ~pospcase-font-lock-lisp-keywords~add~
  and ~pospcase-font-lock-lisp-keywords~remove~ to for highlight
  toggling.

* How to Write Your Pospcase Font Lock Keywords
  Unfortunately current ~pospcase-font-lock~ limitation doesn’t allow
  you to simply write ~pcase~ patterns and let the software to take care
  of the rest.

  There are some concept you need to know before writing functional
  keywords.

** Anchored-Matchers
   ~pcase~ macro, this package is heavily depending on, is not
   particularly designed to match arbitrary length list. To overcome
   the limitation, seven anchored-matchers are implemented so far.

    - varlist
    - varlist-cars
    - key
    - defstruct
    - flet
    - destructuring
    - macrolet

** Data flow
   Anchored-matchers call ~pospcase-at~ and ~pospcase-read~ to parse
   S-expression and get positional metadata.

   ~pospcase-at~ returns cons cells in ~(start . end)~.

   ~pospcase-read~ returns S-expression tree with each node with cons
   cell in ~(sexp . (start . end))~

   Anchored-matchers either manually collect ~(start . end)~ pairs of
   interest or call ~pospcase~, ~pospcase-at~ or ~pospcase-read~ repeatedly
   on each start position ~(car (start . end))~ of interested
   S-expression and collect the result.

   Structure the collected ~(start . end)~ pairs in ~pospcase--matches~
   suitable for ~pospcase–iterator~ consumption like this:

   #+BEGIN_SRC emacs-lisp
     (((start . end)              ; (match-string 1) of first (match-data)
       (start . end))             ; (match-string 2) of first (match-data)

      ((start . end)              ; (match-string 1) of second (match-data)
       (start . end)))            ; (match-string 2) of second (match-data)
   #+END_SRC

   ~pospcase–iterator~ set ~car~ of ~pospcase--matches~ to ~~match-data~ using
   ~set-match-data~.

** Emacs-Lisp-fy
   The thing is, Emacs Lisp doesn’t have reader macro. In ~pospcase~
   context it means you can’t really use Emacs’s build-in reader
   ~read-from-string~ to parse Common Lisp’s S-expressions.

   To circumvent and not really tackle the limitation,
   ~pospcase--read-from-string~ does quick hack using regexp to convert
   unless unparsable S-expressions into Emacs Lisp counterpart as
   smoothly as possible.

   It’s simple text replacement rule. So don’t expect too much. If you
   experience a major problem you can’t think any way to circumvent,
   well, accept it as unparsable and give up the fancy highlighting
   for that section.

** Quirks
   Admittedly, ~pospcase-font-lock~ do something very weird. Here, I’m
   talking about anchored-matchers. As you can see all of them calls
   ~pospcase--call-iterator~ macro. True to its name, the macro realize
   the behavior of the iterator pattern (very crudely using a global
   variable ~pospcase--matches~ as the place holder for pre-collected
   data.) I’m not very please with the implementation either. But I
   think making lambda functions dynamically for each iterators,
   managing and dispatching them correct for each call, is far
   complexer than current implementation. And ultimately Emacs’s font
   locking (and jit-lock) is single-threaded. So I decided it doesn’t
   worth the trouble to implement proper iterator.

   You may ask why do you have to implement iterator in the first
   place? Well, clearly Emacs’ font-lock.el was written with
   regexp-based crawler like behavior in mind. So
   ~font-lock-add-keywords~ was designed accordingly.  Lazy me just
   don’t want to reimplement everything from scratch. Obviously I’m
   misusing them. And this is why ~pospcase-font-lock~ needs its weird
   iterator.

* How to use ~pospcase~, ~pospcase-at~, ~pospcase-read~
  If you have some reason to directly get positions of S-expressions
  in a buffer, you can use ~pospcase-at~ with ~pcase~ like syntax:

  #+BEGIN_SRC emacs-lisp
    (pospcase-at (point-min) '((`,exp exp)))
  #+END_SRC

  #+RESULTS:
  : (1 . 41)

  More detailed explanation can be found in ~pospcase-read~ docstring.


* Limitation of ~pospcase~, ~pospcase-at~, ~pospcase-read~

* Limitation of ~pospcase-font-lock~
** Secretly using Regular Expression
  ~pospcase-font-lock~ totally depends on ~pcase~. But it still use regexp
  for searching heading keywords. The reason why I don’t use something
  like [[https://github.com/emacsmirror/el-search][el-search]] is I fear further degeneration of performance. And I
  feel it’s overkill.

  So far I have no use case for in-middle keyword matching. So it’s
  not implemented. Purposely ~pospcase-font-lock~ only supports heading
  keyword patterns.

** No support for nest in binding list
   Following doesn’t work:
   
  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  But following works:

  #+BEGIN_SRC emacs-lisp
    (let ((foo 'bar))
      (let ((baz foo))
        baz))
  #+END_SRC

  and:

  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let* ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  Note that the last snippet use two different keywords ~let~ and ~let*~.

  Maybe this is due to my ignorance of font-lock internals and not a
  real technical limitation. I’m eager to fix it.

** Anchored-matcher
   Currently only one anchored-matcher per-pattern is supported. This
   limitation is simply because I have yet encountered the codebase
   utilizing multiple arbitrary length lists for its syntax. Maybe
   someday I feel fancy and implement it, though.
