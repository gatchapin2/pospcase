#+TITLE: ~pospcase~: A ~pcase~ variant for getting positional metadata

* About ~pospcase~
  ~pospcase~ is a package for extracting S-expression positions using
  ~pcase~ pattern matching ability.

  At this moment the package contains a pattern matcher ~pospcase~ and a
  pretty advanced code highlighter for ~lisp-mode~ and ~emacs-lisp-mode~.

* Rational
  Emacs’s font-locking (highlighting) heavily relies on regular
  expression (regexp). There’s already an attempt to do [[https://github.com/Lindydancer/lisp-extra-font-lock][extra
  highlighting]] for Lisp and Emacs Lisp. Which is completely regexp
  based. When you follow the above link and look into its
  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html][anchored-matcher]], let’s say ~lisp-extra-font-lock-match-let~ for
  example.  you’ll notice parsing S-expression with regexp is
  inherently awkward and error-prone (you also notice in-between
  comments break the parsing too). To overcome the problem, you
  basically have to call ~syntax-ppss~ and ~forward-comment~ everywhere in
  pattern matching part of your code. The resulting code is quite
  unreadable mess of regexp matchings, constant syntax-table
  checkings, and numerous corner-case coverages. If you want to see
  what kind of mess it will be. Here’s an example:

  #+BEGIN_SRC emacs-lisp
    ;;; match and collect all symbol positions within the same nested level
    (let ((current-level (car (syntax-ppss)))
          (symbol-pat "\\_<\\(?:\\sw\\|\\s_\\)+\\_>")
          (skip-pat "\\(?:\\sw\\|\\s_\\|\\s \\)"))

      (if (zerop current-level)
          (error "The point is in the top level.")
        (backward-up-list)
        ;; skip the starting non-symbol chars
        (skip-chars-forward skip-pat)

        (cl-loop
         with result

         ;; return if the task ended or the `point' is out of scope
         when (or (eobp) (< (car (syntax-ppss)) current-level)) return result

         ;; actual matching
         do (progn
              (forward-comment most-positive-fixnum)
              (looking-at symbol-pat))

         ;; collect matched symbol's range in a cons pair
         if (= (car (syntax-ppss)) current-level)
         do (setq result (cons (cons (match-beginning 0) (match-end 0)) result))

         ;; skip non-interesting characters
         do (progn
              (goto-char (match-end 0))
              (skip-chars-forward skip-pat)))))
  #+END_SRC

  Next I present you what kind of code it will be like if you use
  ~pospcase-read~, the S-expression reader I implemented, to get the
  same result:

  #+BEGIN_SRC emacs-lisp
    (if (zerop current-level)
        (error "The point is in the top level.")
      (backward-up-list)

      (cl-loop for pair in (car (pospcase-read (point))) ; `car' because `cdr' contains
                                                         ; position data of entire list
               collect (cdr pair)))
  #+END_SRC

  Well, I admit it’s exaggerated to illustrate the point. The actual
  code is messier than this. But I hope you see some novelty into the
  way this package is trying to achieve.

  In addition, Emacs recently got this nice pattern matching macro
  called ~pcase~. Nowadays You can easily match and destructure any kind
  of S-expression whenever you want.

  So I decided it’s a good time to write a ~pcase~-based position
  extractor and use it for a font-locker.

* How to Enable Font Lock
  To turn of the font-lock for lisp-mode and emacs-lisp-mode, run:

  #+BEGIN_SRC emacs-lisp
    (require 'pospcase)
    (pospcase-font-lock-lisp-setup)
  #+END_SRC

  The above code add ~pospcase-font-lock-lisp-keywords~add~ to the two
  lisp major-modes’ hooks. ~pospcase-font-lock~ don’t have minor-mode
  unlike ~lisp-extra-font-lock~. The reason is I designed font-lock
  specific functions so I can easily making buffer-local keywords. So
  I can simultaneously work on different codebases in a single Emacs
  session with different highlighting rules for each codebase. It may
  never happened to you, but I’ve actually seen two codebases define
  ~defun*~ themselves with completely different meanings (one of them
  enforce type check) with different argument styles.

* How to use ~pospcase~, ~pospcase-at~, ~pospcase-read~
  If you have some reason to get positions of S-expression in a
  buffer, you can use ~pospcase-at~ with ~pcase~ like syntax:

  #+BEGIN_SRC emacs-lisp
    (pospcase-at (point-min) '((`,exp exp)))
  #+END_SRC

  #+RESULTS:
  : (1 . 41)

  More detailed explanation can be found in ~pospcase-read~ docstring.

* Limitation
  No support for nested binding list like:

  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  But supports:

  #+BEGIN_SRC emacs-lisp
    (let ((foo 'bar))
      (let ((baz foo))
        baz))
  #+END_SRC

  and:

  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let* ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  Note that the last snippet use two different keywords ~let~ and ~let*~.

  This limitation is maybe due to my ignorance of font-lock
  internals. But I’m eager to fix it.

* Font-Lock Specific Limitation
  ~pospcase-font-lock~ totally depends on ~pcase~. But it still use regexp
  for searching heading keywords. I still have no use case for
  in-middle keyword matching. So it isn’t implemented. Therefore
  ~pospcase-font-lock~ only supports heading keyword patterns.
