#+TITLE: ~pospcase~: A ~pcase~ variant for getting positional metadata

* About ~pospcase~
  ~pospcase~ is a package for extracting S-expression positions using
  ~pcase~ pattern matching ability.

  At this moment the package contains a pattern matcher ~pospcase~ and a
  pretty advanced code highlighter for ~lisp-mode~ and ~emacs-lisp-mode~.

* Rational
  Emacs’s font-locking (highlighting) heavily relies on regular
  expression (regexp). There’s already an attempt to do [[https://github.com/Lindydancer/lisp-extra-font-lock][extra
  highlighting]] for Lisp and Emacs Lisp. Which is completely regexp
  based. When you follow the above link and look into its
  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html][anchored-matcher]], let’s say ~lisp-extra-font-lock-match-let~ for
  example.  you’ll notice parsing S-expression with regexp is
  inherently awkward and error-prone (you also notice in-between
  comments break the parsing too). To overcome the problem, you
  basically have to call ~syntax-ppss~ and ~forward-comment~ everywhere in
  pattern matching part of your code. The resulting code is quite
  unreadable mess of regexp matchings, constant syntax-table
  checkings, and numerous corner-case coverages. If you want to see
  what kind of mess it will be. Here’s an example:

  #+BEGIN_SRC emacs-lisp
    ;;; match and collect all symbol positions within the same nested level
    (let ((current-level (car (syntax-ppss)))
          (symbol-pat "\\_<\\(?:\\sw\\|\\s_\\)+\\_>")
          (skip-pat "\\(?:\\sw\\|\\s_\\|\\s \\)"))

      (if (zerop current-level)
          (error "The point is in the top level.")
        (backward-up-list)
        ;; skip the starting non-symbol chars
        (skip-chars-forward skip-pat)

        (cl-loop
         with result

         ;; return if the task ended or the `point' is out of scope
         when (or (eobp) (< (car (syntax-ppss)) current-level)) return result

         ;; actual matching
         do (progn
              (forward-comment most-positive-fixnum)
              (looking-at symbol-pat))

         ;; collect matched symbol's range in a cons pair
         if (= (car (syntax-ppss)) current-level)
         do (setq result (cons (cons (match-beginning 0) (match-end 0)) result))

         ;; skip non-interesting characters
         do (progn
              (goto-char (match-end 0))
              (skip-chars-forward skip-pat)))))
  #+END_SRC

  Next I present you what kind of code it will be like if you use
  ~pospcase-read~, the S-expression reader I implemented, to get the
  same result:

  #+BEGIN_SRC emacs-lisp
    (if (zerop current-level)
        (error "The point is in the top level.")
      (backward-up-list)

      (cl-loop for pair in (car (pospcase-read (point))) ; `car' because `cdr' contains
                                                         ; position data of entire list
               collect (cdr pair)))
  #+END_SRC

  Well, I admit it’s exaggerated to illustrate the point. The actual
  code is messier than this. But I hope you see some novelty behind
  it.

  In addition, Emacs recently got this nice pattern matching macro
  called ~pcase~. Nowadays You can easily match and destructure any kind
  of S-expression whenever you want.

  So I decided it’s a good time to write a ~pcase~-based position
  extractor and use it for a font-locker.

* How to Enable Font Lock
  To turn of the font-lock for lisp-mode and emacs-lisp-mode, run:

  #+BEGIN_SRC emacs-lisp
    (require 'pospcase)
    (pospcase-font-lock-lisp-setup)
  #+END_SRC

  The above code add ~pospcase-font-lock-lisp-keywords~add~ to the two
  lisp major-modes’ hooks. ~pospcase-font-lock~ don’t have minor-mode
  unlike ~lisp-extra-font-lock~. The reason is I designed font-lock
  specific functions so I can easily making buffer-local keywords. So
  I can simultaneously work on different codebases in a single Emacs
  session with different highlighting rules for each codebase. It may
  never happened to you, but I’ve actually seen two codebases define
  ~defun*~ themselves with completely different meanings (one of them
  enforce type check) with different argument styles. If you want to
  enforce the same highlighting rule to a single major-mode,
  minor-mode is the best way to do it. But your workflow involves
  numerous per-project highlighting rules, I feel there’s not much
  point to use it. But by all means I don’t oppose defining your own
  minor-mode. You can write it by simply using
  ~pospcase-font-lock-lisp-keywords~add~ and
  ~pospcase-font-lock-lisp-keywords~remove~ to for highlight toggling.

* How to use ~pospcase~, ~pospcase-at~, ~pospcase-read~
  If you have some reason to get positions of S-expression in a
  buffer, you can use ~pospcase-at~ with ~pcase~ like syntax:

  #+BEGIN_SRC emacs-lisp
    (pospcase-at (point-min) '((`,exp exp)))
  #+END_SRC

  #+RESULTS:
  : (1 . 41)

  More detailed explanation can be found in ~pospcase-read~ docstring.


* How ~pospcase-font-lock~ Works
** The quirks
  Admittedly, ~pospcase-font-lock~ do something very weird. Here, I’m
  talking about anchored-matchers. As you can see all of them calls
  ~pospcase--call-iterator~ macro. True to its name, the macro realize
  the behavior of the iterator pattern (very crudely using a global
  variable ~pospcase--matches~ as the place holder for pre-collected
  data.) I’m not very please with the implementation either. But I
  think making lambda functions dynamically for each iterators,
  managing and dispatching them correct for each call, is far
  complexer than current implementation. And ultimately Emacs’s
  font locking (and jit-lock) is single-threaded. So I decided it
  doesn’t worth the trouble to implement proper iterator.

  You may ask why do you have to implement iterator in the first
  place? Well, because it’s how ~font-lock-add-keywords~ is designed,
  and I don’t want to reimplement font-lock feature from
  scratch. ~font-lock.el~ is obviously designed for regexp-based pattern
  matching and I’m using it wrongly. This is why ~pospcase-font-lock~
  needs this weird iterator.

** Data flow
  To understand and add your own font lock keywords without feeling
  uncomfortable, there are some points you have to know:

*** The anchored-matchers
    ~pcase~ is not particularly designed to match arbitrary length list
    of specific element pattern. To overcome the limitation currently
    seven anchored-matchers are implemented using ~pospcase-at~ or
    ~pospcase-read~.

    - varlist
    - varlist-cars
    - key
    - defstruct
    - flet
    - destructuring
    - macrolet


* Limitation of ~pospcase~, ~pospcase-at~, ~pospcase-read~

* Limitation of ~pospcase-font-lock~
** Secretly using Regular Expression
  ~pospcase-font-lock~ totally depends on ~pcase~. But it still use regexp
  for searching heading keywords. The reason why I don’t use something
  like [[https://github.com/emacsmirror/el-search][el-search]] is I fear further degeneration of performance. And I
  feel it’s overkill.

  So far I have no use case for in-middle keyword matching. So it’s
  not implemented. Purposely ~pospcase-font-lock~ only supports heading
  keyword patterns.

** No support for nest in binding list
   Following doesn’t work:
   
  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  But following works:

  #+BEGIN_SRC emacs-lisp
    (let ((foo 'bar))
      (let ((baz foo))
        baz))
  #+END_SRC

  and:

  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let* ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  Note that the last snippet use two different keywords ~let~ and ~let*~.

  Maybe this is due to my ignorance of font-lock internals and not a
  real technical limitation. I’m eager to fix it.

