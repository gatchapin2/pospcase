#+TITLE: ~pospcase~: `pcase' powered position extraction and S-expression font-lock

* About ~pospcase~
  ~pospcase~ is a package for extracting S-expression positions using
  ~pcase~ pattern matching ability.

  At this moment the package contains a pattern matcher ~pospcase~ and a
  pretty advanced code highlighter for ~lisp-mode~ and ~emacs-lisp-mode~.


* Introduction
  Emacs’s font-locking (highlighting) heavily relies on regular
  expression (regexp). There’s already an attempt to do [[https://github.com/Lindydancer/lisp-extra-font-lock][extra
  highlighting]] for Lisp and Emacs Lisp. Which is completely regexp
  based. When you follow the above link and look into its
  [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Search_002dbased-Fontification.html][anchored-matcher]], let’s say ~lisp-extra-font-lock-match-let~ for
  example.  you’ll notice parsing S-expression with regexp is
  inherently awkward and error-prone (you also notice in-between
  comments break the parsing too). To overcome the problem, you
  basically have to call ~syntax-ppss~ and ~forward-comment~ everywhere in
  pattern matching part of your code. The resulting code is quite
  unreadable mess of regexp matchings, constant syntax-table
  checkings, and numerous corner-case coverages. If you want to see
  what kind of mess it will be. Here’s an example:

  #+BEGIN_SRC emacs-lisp
    ;;; match and collect all symbol positions within the same nested level
    (let ((current-level (car (syntax-ppss)))
          (symbol-pat "\\_<\\(?:\\sw\\|\\s_\\)+\\_>")
          (skip-pat "\\(?:\\sw\\|\\s_\\|\\s \\)"))

      (if (zerop current-level)
          (error "The point is in the top level.")
        (backward-up-list)
        ;; skip the starting non-symbol chars
        (skip-chars-forward skip-pat)

        (cl-loop
         with result

         ;; return if the task ended or the `point' is out of scope
         when (or (eobp) (< (car (syntax-ppss)) current-level)) return result

         ;; actual matching
         do (progn
              (forward-comment most-positive-fixnum)
              (looking-at symbol-pat))

         ;; collect matched symbol's range in a cons pair
         if (= (car (syntax-ppss)) current-level)
         do (setq result (cons (cons (match-beginning 0) (match-end 0)) result))

         ;; skip uninteresting characters
         do (progn
              (goto-char (match-end 0))
              (skip-chars-forward skip-pat)))))
  #+END_SRC

  Next I present you what kind of code it will be like if you use
  ~pospcase-read~, the S-expression reader I implemented, to get the
  same result:

  #+BEGIN_SRC emacs-lisp
    ;;; collect all symbol positions within the same nested level
    (if (zerop (car (syntax-ppss)))
        (error "The point is in the top level.")
      (backward-up-list)

      (cl-loop for pair in (car (pospcase-read (point))) ; `car' because `cdr' contains
                                                         ; position data of entire list
               if (symbolp (car pair)) collect (cdr pair)))

  #+END_SRC

  Well, I admit it’s exaggerated to illustrate the point. The actual
  code is messier than this. But I hope you see some novelty behind
  it.

  In addition, Emacs recently got this nice pattern matching macro
  called ~pcase~. Nowadays You can easily match and destructure any kind
  of S-expression whenever you want.

  So I decided it’s a good time to write a ~pcase~-based position
  extractor and use it for a lisp code highlighter.


* How to Enable Pospcase Font-Lock
  To turn on the font-lock for lisp-mode and emacs-lisp-mode, add the
  following code to init file:

  #+BEGIN_SRC emacs-lisp
    (add-hook 'after-init-hook
              (lambda ()
                (add-to-list 'load-path
                             "/path/to/pospcase") ; change it appropriately
                (require 'pospcase)
                (pospcase-font-lock-lisp-setup)))
  #+END_SRC

  The above code add ~pospcase-font-lock-lisp-keywords~add~ to the said
  two lisp major-modes’ hooks. Currently ~pospcase-font-lock~ doesn’t
  have minor-mode unlike ~lisp-extra-font-lock~. The reason is I
  designed the font-lock specific functions so I can easily making
  buffer-local keywords. Then I can simultaneously work on different
  codebases in a single Emacs session with different highlighting
  rules with the same keywords for each codebases. It may never
  happened to you, but I’ve actually seen two codebases define ~defun*~
  by themselves with completely different meanings with different
  argument styles (one of them enforce type check with ~->~
  (dash-greater-than) as the infix).

  If you want to enforce the same highlighting rule to a single
  major-mode, minor-mode is the best way to do it. But your workflow
  involves numerous per-project highlighting rules, I feel there’s not
  much point using minor-mode for it.

  But, by all means I don’t oppose writing your own minor-mode if you
  find it useful. You can write it by simply using
  ~pospcase-font-lock-lisp-keywords-add~ and
  ~pospcase-font-lock-lisp-keywords-remove~ to for toggling them.


* The First Example
  ~pospcase~ is written because I wanted flexible and easier way to add
  new highlighting rules to fully embrace Lisp’s ultimate
  flexibility. The function ~pospcase-font-lock~ is specifically
  written for that purpose.

  Suppose I want to add a highlight rule for a new Common Lisp macro
  ~mydefun,~ I can simply write like this:

  #+BEGIN_SRC emacs-lisp
    (pospcase-font-lock
     'lisp-mode                             ; major-mode name

     '(`(mydefun ,name ,args . ,_))         ; `pcase' pattern to match

     ;; font specs
     '(font-lock-keyword-face               ; face of `mydefun' keyword

       (name
        . (font-lock-function-name-face))   ; face of new function `name’

       ((args . varlist-cars)               ; `args' is arbitrary length
                                            ; list of arguments.

        . (font-lock-variable-name-face)))) ; face of every arguments
  #+END_SRC

  Hopefully it’s straightforward enough for you. The most foreign part
  is ~varlist-cars~. To understand what it is, You have to understand
  Anchored-matchers. But I’ll explain with more details later.

* An Example Work Flow
** Custom File
  #+BEGIN_SRC emacs-lisp
    (load-file "~/.emacs.d/pospcase-custom.el")
  #+END_SRC

  In pospcase-custom.el, write following code:

  #+BEGIN_SRC emacs-lisp
    (require 'pospcase)

    (eval
     `(defun my-add-new-font-lock-keyword ()
        (interactive)
        (let* ((str
                (format "
    (pospcase-font-lock
     '%s
     '(`(foo ,bar ,baz . ,_))
     '(font-lock-keyword-face
       (bar . (font-lock-function-name-face))
       ((baz . varlist-cars) . (font-lock-variable-name-face))))"
                        major-mode)))
          (find-file ,(buffer-file-name))
          (goto-char (point-max))
          (insert str "\n")
          (backward-char (- (1+ (length str)) (string-match "foo" str))))))
  #+END_SRC

  And now whenever you encounter a new keyword which needs extra
  highlighting for maximum readability, you can just ~M-x
  my-add-new-font-lock-keyword~ and start writing a new keyword right
  away with convenient cookie cutter (you can also write a new snippet
  for Yasnippet if it suits you better).

  If you are satisfied with the new keyword, save the buffer, ~C-M-x~ or
  ~C-x C-e~ or whatever to activate it, then go back to your project and
  reactivate the major mode, for example ~M-x lisp-mode~ for a Common
  Lisp project. Now you see the new font-lock rule is applied and the
  code is highlighted accordingly.

** Buffer-Local Keywords
   Lisp’s flexibility sometimes causes unfortunate accidents that two
   people to choose the exact same keyword for complete different
   purpose in their own codebases. Two different definitions means two
   different highlighting rules. You need buffer-local keyword rules
   for this.

   For example, ASDF package system for Common Lisp defines ~defun*~ and
   use it internally. To highlight the keyword you wrap your
   ~pospcase-font-lock~ statement like this:

   #+BEGIN_SRC emacs-lisp
     (add-hook
      'lisp-mode-hook
      (lambda ()
        (when (and (buffer-file-name)
                   (equal (file-name-nondirectory (buffer-file-name)) "asdf.lisp"))

          (pospcase-font-lock 'lisp-mode
                              '(`(defun* ,name ,args . ,_)
                                `(defgeneric* ,name ,args . ,_))
                              '(font-lock-keyword-face
                                (name .
                                      (font-lock-function-name-face))
                                ((args . varlist-cars)
                                 .
                                 ((pospcase-font-lock-variable-face-form
                                   (match-string 1)))))
                              t))))          ; buffer-local-p
   #+END_SRC

   Writing a predicate for detecting which codebase the file belongs
   is sometimes tricky. So be more creative than the above example if
   your use case demands it.

* Before Writing Your Own Font-Lock Keywords
  Unfortunately current ~pospcase-font-lock~ design doesn’t allow you to
  simply write ~pcase~ patterns and let Emacs to take care of the rest.

  This is largely due to my design decision to keep the implementation
  as straightforward as possible even at the expense of introducing
  foreign concept to the users. But if I find better balance between
  implementation complexity and ergonomic API design, I’m going to
  overhaul ~pospcase-font-lock~ willingly.

  That’s said, here are the prior knowledges you need to know before
  writing your own font-lock keywords.

** Anchored-Matchers
   ~pcase~, which ~pospcase~ is heavily depending on, is not particularly
   designed for pattern-matching arbitrary length S-expression. To
   overcome the limitation, so far, seven anchored-matchers are
   implemented.

    - ~varlist~
    - ~varlist-cars~
    - ~key~
    - ~defstruct~
    - ~flet~
    - ~destructuring~
    - ~macrolet~

   I’m going to explain each of them.

*** ~Varlist~
    If you pair a pattern variable with ~varlist~ in font specs of
    ~pospcase-font-lock~ like:

    #+BEGIN_SRC emacs-lisp
      (args . varlist)
    #+END_SRC

    It means ~args~ is a list of arbitrary length with either symbol or
    two length list. Like argument list of ~defmethod~:

    #+BEGIN_SRC emacs-lisp
      (defmethod foo ((bar class1) (baz class2) qux quux)
        body)
    #+END_SRC

* Technical Details
** Data flow
   Anchored-matchers call ~pospcase-at~ and ~pospcase-read~ to parse
   S-expression and get positional metadata.

   ~pospcase-at~ returns cons cells in ~(start . end)~.

   ~pospcase-read~ returns S-expression tree with each node with cons
   cell in ~(sexp . (start . end))~

   Anchored-matchers either manually collect ~(start . end)~ pairs of
   interest or call ~pospcase~, ~pospcase-at~ or ~pospcase-read~ repeatedly
   on each start position ~(car (start . end))~ of interested
   S-expression and collect the result.

   Structure the collected ~(start . end)~ pairs in ~pospcase--matches~
   suitable for ~pospcase–iterator~ consumption like this:

   #+BEGIN_SRC emacs-lisp
     (((start . end)              ; (match-string 1) of first (match-data)
       (start . end))             ; (match-string 2) of first (match-data)

      ((start . end)              ; (match-string 1) of second (match-data)
       (start . end)))            ; (match-string 2) of second (match-data)
   #+END_SRC

   ~pospcase–iterator~ set ~car~ of ~pospcase--matches~ to ~~match-data~ using
   ~set-match-data~.

** Quirks of Pospcase Font Lock
*** Iterator
   Admittedly, ~pospcase-font-lock~ do something very weird. Here, I’m
   talking about anchored-matchers. As you can see all of them calls
   ~pospcase--call-iterator~ macro. True to its name, the macro realize
   the behavior of the iterator pattern (very crudely using a global
   variable ~pospcase--matches~ as the place holder for pre-collected
   data.) I’m not very please with the implementation either. But I
   think making lambda functions dynamically for each iterators,
   managing and dispatching them correct for each call, is far
   complexer than current implementation. And ultimately Emacs’s
   font-lock (and jit-lock) is single-threaded. So I decided it
   doesn’t worth the trouble to implement proper iterator.

   You may ask why do you have to implement iterator in the first
   place? Well, clearly Emacs’ font-lock.el was written with
   regexp-based crawler like behavior in mind. So
   ~font-lock-add-keywords~ was designed accordingly.  Lazy me just
   don’t want to reimplement everything from scratch. Obviously I’m
   misusing them. And this is why ~pospcase-font-lock~ needs its weird
   iterator.

*** Emacs-Lisp-fy
   The thing is, Emacs Lisp doesn’t have reader macro. In ~pospcase~
   context it means you can’t really use Emacs’s build-in reader
   ~read-from-string~ to parse Common Lisp’s S-expressions.

   To circumvent and not really tackle the limitation,
   ~pospcase--read-from-string~ does quick hack using regexp to convert
   unless unparsable S-expressions into Emacs Lisp counterpart as
   smoothly as possible.

   It’s simple text replacement rule. So don’t expect too much. If you
   experience a major problem you can’t think any way to circumvent,
   well, accept it as unparsable and give up the fancy highlighting
   for that section.


** How to use ~pospcase~, ~pospcase-at~, ~pospcase-read~
  If you have some reason to directly get positions of S-expressions
  in a buffer, you can use ~pospcase-at~ with ~pcase~ like syntax:

  #+BEGIN_SRC emacs-lisp
    (pospcase-at (point-min) '((`,exp exp)))
  #+END_SRC

  #+RESULTS:
  : (1 . 41)

  More detailed explanation can be found in ~pospcase-read~ docstring.


** Limitation of ~pospcase~, ~pospcase-at~, ~pospcase-read~


** Limitation of ~pospcase-font-lock~
** Secretly using Regular Expression
  ~pospcase-font-lock~ totally depends on ~pcase~. But it still use regexp
  for searching heading keywords. The reason why I don’t use something
  like [[https://github.com/emacsmirror/el-search][el-search]] is I fear further degeneration of performance. And I
  feel it’s overkill.

  So far I have no use case for in-middle keyword matching. So it’s
  not implemented. Purposely ~pospcase-font-lock~ only supports heading
  keyword patterns.

*** No support for nest in binding list
   Following doesn’t work:
   
  #+BEGIN_SRC emacs-lisp
    (let ((foo
           (let ((bar 'baz))
             bar)))
      foo)
  #+END_SRC

  But following works:

  #+BEGIN_SRC emacs-lisp
    (let ((foo 'bar))
      (let ((baz foo))
        baz))
  #+END_SRC

  Maybe this is due to my ignorance of font-lock internals and not a
  real technical limitation. I’m eager to fix it.

*** No support for multiple anchored-matcher
   Currently only single arbitrary length list matching per-pattern is
   allowed. For example, ~defclass~ has syntax:

   #+BEGIN_SRC emacs-lisp
     `(defclass ,name ,supers ,slots . ,_)
   #+END_SRC

   Where ~supers~ is a list of super-classes, and ~slots~ is a list of
   class’s variables.

   To over come the limitation, font-lock keyword of ~defclass~ is
   declared as follow:

   #+BEGIN_SRC emacs-lisp
     (pospcase-font-lock 'lisp-mode
                         '(`(defclass ,name ,supers ,slots . ,_))
                         '(font-lock-keyword-face
                           (name . (default))
                           (supers . (default))
                           ((slots . varlist-cars) . (font-lock-variable-name-face))))

     (pospcase-font-lock 'lisp-mode
                         '(`(defclass ,name ,supers . ,_))
                         '(font-lock-keyword-face
                           (name . (font-lock-type-face))
                           ((supers . varlist-cars) . (font-lock-type-face))))
   #+END_SRC

   Note ~pospcase-font-lock~ adds new keyword at the start of a keyword
   list. In other word, the last added keyword will be highlighted
   first. And since keywords are internally processed with ~'append~
   flag, the below highlighting is not going to be overwritten by the
   above keyword’s ~default~ face.

   I’m aware it’s quite unintuitive. Maybe someday I might properly
   implement support for multiple anchored matchers.
